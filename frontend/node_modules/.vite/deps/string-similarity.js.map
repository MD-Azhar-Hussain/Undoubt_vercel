{
  "version": 3,
  "sources": ["../../string-similarity/src/index.js"],
  "sourcesContent": ["module.exports = {\r\n\tcompareTwoStrings:compareTwoStrings,\r\n\tfindBestMatch:findBestMatch\r\n};\r\n\r\nfunction compareTwoStrings(first, second) {\r\n\tfirst = first.replace(/\\s+/g, '')\r\n\tsecond = second.replace(/\\s+/g, '')\r\n\r\n\tif (first === second) return 1; // identical or empty\r\n\tif (first.length < 2 || second.length < 2) return 0; // if either is a 0-letter or 1-letter string\r\n\r\n\tlet firstBigrams = new Map();\r\n\tfor (let i = 0; i < first.length - 1; i++) {\r\n\t\tconst bigram = first.substring(i, i + 2);\r\n\t\tconst count = firstBigrams.has(bigram)\r\n\t\t\t? firstBigrams.get(bigram) + 1\r\n\t\t\t: 1;\r\n\r\n\t\tfirstBigrams.set(bigram, count);\r\n\t};\r\n\r\n\tlet intersectionSize = 0;\r\n\tfor (let i = 0; i < second.length - 1; i++) {\r\n\t\tconst bigram = second.substring(i, i + 2);\r\n\t\tconst count = firstBigrams.has(bigram)\r\n\t\t\t? firstBigrams.get(bigram)\r\n\t\t\t: 0;\r\n\r\n\t\tif (count > 0) {\r\n\t\t\tfirstBigrams.set(bigram, count - 1);\r\n\t\t\tintersectionSize++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn (2.0 * intersectionSize) / (first.length + second.length - 2);\r\n}\r\n\r\nfunction findBestMatch(mainString, targetStrings) {\r\n\tif (!areArgsValid(mainString, targetStrings)) throw new Error('Bad arguments: First argument should be a string, second should be an array of strings');\r\n\t\r\n\tconst ratings = [];\r\n\tlet bestMatchIndex = 0;\r\n\r\n\tfor (let i = 0; i < targetStrings.length; i++) {\r\n\t\tconst currentTargetString = targetStrings[i];\r\n\t\tconst currentRating = compareTwoStrings(mainString, currentTargetString)\r\n\t\tratings.push({target: currentTargetString, rating: currentRating})\r\n\t\tif (currentRating > ratings[bestMatchIndex].rating) {\r\n\t\t\tbestMatchIndex = i\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tconst bestMatch = ratings[bestMatchIndex]\r\n\t\r\n\treturn { ratings: ratings, bestMatch: bestMatch, bestMatchIndex: bestMatchIndex };\r\n}\r\n\r\nfunction areArgsValid(mainString, targetStrings) {\r\n\tif (typeof mainString !== 'string') return false;\r\n\tif (!Array.isArray(targetStrings)) return false;\r\n\tif (!targetStrings.length) return false;\r\n\tif (targetStrings.find( function (s) { return typeof s !== 'string'})) return false;\r\n\treturn true;\r\n}\r\n"],
  "mappings": ";;;;;AAAA;AAAA;AAAA,WAAO,UAAU;AAAA,MAChB;AAAA,MACA;AAAA,IACD;AAEA,aAAS,kBAAkB,OAAO,QAAQ;AACzC,cAAQ,MAAM,QAAQ,QAAQ,EAAE;AAChC,eAAS,OAAO,QAAQ,QAAQ,EAAE;AAElC,UAAI,UAAU,OAAQ,QAAO;AAC7B,UAAI,MAAM,SAAS,KAAK,OAAO,SAAS,EAAG,QAAO;AAElD,UAAI,eAAe,oBAAI,IAAI;AAC3B,eAAS,IAAI,GAAG,IAAI,MAAM,SAAS,GAAG,KAAK;AAC1C,cAAM,SAAS,MAAM,UAAU,GAAG,IAAI,CAAC;AACvC,cAAM,QAAQ,aAAa,IAAI,MAAM,IAClC,aAAa,IAAI,MAAM,IAAI,IAC3B;AAEH,qBAAa,IAAI,QAAQ,KAAK;AAAA,MAC/B;AAAC;AAED,UAAI,mBAAmB;AACvB,eAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AAC3C,cAAM,SAAS,OAAO,UAAU,GAAG,IAAI,CAAC;AACxC,cAAM,QAAQ,aAAa,IAAI,MAAM,IAClC,aAAa,IAAI,MAAM,IACvB;AAEH,YAAI,QAAQ,GAAG;AACd,uBAAa,IAAI,QAAQ,QAAQ,CAAC;AAClC;AAAA,QACD;AAAA,MACD;AAEA,aAAQ,IAAM,oBAAqB,MAAM,SAAS,OAAO,SAAS;AAAA,IACnE;AAEA,aAAS,cAAc,YAAY,eAAe;AACjD,UAAI,CAAC,aAAa,YAAY,aAAa,EAAG,OAAM,IAAI,MAAM,wFAAwF;AAEtJ,YAAM,UAAU,CAAC;AACjB,UAAI,iBAAiB;AAErB,eAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC9C,cAAM,sBAAsB,cAAc,CAAC;AAC3C,cAAM,gBAAgB,kBAAkB,YAAY,mBAAmB;AACvE,gBAAQ,KAAK,EAAC,QAAQ,qBAAqB,QAAQ,cAAa,CAAC;AACjE,YAAI,gBAAgB,QAAQ,cAAc,EAAE,QAAQ;AACnD,2BAAiB;AAAA,QAClB;AAAA,MACD;AAGA,YAAM,YAAY,QAAQ,cAAc;AAExC,aAAO,EAAE,SAAkB,WAAsB,eAA+B;AAAA,IACjF;AAEA,aAAS,aAAa,YAAY,eAAe;AAChD,UAAI,OAAO,eAAe,SAAU,QAAO;AAC3C,UAAI,CAAC,MAAM,QAAQ,aAAa,EAAG,QAAO;AAC1C,UAAI,CAAC,cAAc,OAAQ,QAAO;AAClC,UAAI,cAAc,KAAM,SAAU,GAAG;AAAE,eAAO,OAAO,MAAM;AAAA,MAAQ,CAAC,EAAG,QAAO;AAC9E,aAAO;AAAA,IACR;AAAA;AAAA;",
  "names": []
}
